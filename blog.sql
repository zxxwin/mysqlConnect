/*
Navicat MySQL Data Transfer

Source Server         : newX
Source Server Version : 50710
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 50710
File Encoding         : 65001

Date: 2017-12-01 16:51:30
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for articles
-- ----------------------------
DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles` (
  `articleId` int(8) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) DEFAULT NULL,
  `descr` varchar(2048) DEFAULT '本文暂时没有摘要可以显示' COMMENT 'describe',
  `cover` varchar(10000) DEFAULT NULL,
  `categoryId` int(4) NOT NULL DEFAULT '0',
  `createTime` datetime DEFAULT NULL,
  `content` text,
  `viewNum` int(8) DEFAULT '0',
  `favorNum` int(8) DEFAULT '0',
  `remove` int(1) DEFAULT '0',
  `updateTime` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`articleId`),
  KEY `categoryId` (`categoryId`),
  CONSTRAINT `articles_ibfk_1` FOREIGN KEY (`categoryId`) REFERENCES `categories` (`categoryId`)
) ENGINE=InnoDB AUTO_INCREMENT=77 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of articles
-- ----------------------------
INSERT INTO `articles` VALUES ('1', '图的关键路径算法，c语言实现。', 'pageHelper是个很方便的工具，我们来看看怎么去使用', 'https://img.c7sky.com/2017/03/26/playing-morse-code-web-audio-api-banner.jpg', '1', '2017-10-20 11:32:11', '<p>我们以下图为例子：</p><p><img src=\"http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1506602874199blog.jpg?Expires=1821962867&amp;OSSAccessKeyId=LTAIw9QfPaWovM1p&amp;Signature=OUYkSY%2FoQonhzR0aVmmcU2EO%2FU8%3D\" class=\"\"></p><p><br></p><blockquote>图来自《大话数据结构》</blockquote><p>本算法基于邻接表来实现，首先定义一些基本的变量，与结构体</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>#include &lt;stdio.h&gt;\n#define MAXVEX 65535\n#define INFINITY 65535\nint *etv, *ltv;     //事件最早发生时间和最迟发生时间数组；\nint *stack2;        //用于存储拓扑序列的栈\nint top2;           //用于stack2的指针\n\ntypedef struct EdgeNode {   //边表节点\n  int adjvex;               //邻接点域，存储该顶点对应的下标\n  int weight;                //存储权值\n  struct EdgeNode *next;      //链域，指向下一个邻接点\n}EdgeNode;\n\ntypedef struct VextexNode{   // 顶点表节点\n  int in;                    // 顶点入度\n  int data;                     // 顶点域存储顶点信息\n  EdgeNode * firstedge;       // 边表头指针\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct {            // 定义图\n  AdjList adjList;\n  int numVertexes, numEdges;\n}graphAdjList, *GraphAdjList;\n</code></pre><p>初始化图：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>CreateALGraph(GraphAdjList G) {\n  int j, k, i, quan;\n  EdgeNode* e;\n  printf(\"请输入顶点数和边数\\n\");\n  scanf(\"%d %d\", &amp;G -&gt; numVertexes, &amp;G -&gt; numEdges);\n  fflush(stdin);\n  for (i = 0; i &lt; G -&gt; numVertexes; i++) {\n    printf(\"请输入%d个元素和入度\\n\", i);\n    scanf(\"%c %d\", &amp;G -&gt; adjList[i].data, &amp;G -&gt; adjList[i].in);   //输入顶点信息\n    fflush(stdin);\n    G -&gt; adjList[i].firstedge = NULL;    //边表置空\n  }\n  for (k = 0; k &lt; G -&gt; numEdges; k++) {\n    printf(\"请输入边的起点序号，终点序号以及权重\\n\");\n    scanf(\"%d %d %d\", &amp;i, &amp;j, &amp;quan);\n    fflush(stdin);\n    e = (EdgeNode *)malloc(sizeof(EdgeNode));\n    e -&gt; adjvex = j;\n    e -&gt; weight = quan;\n    e -&gt; next = G -&gt; adjList[i].firstedge;\n    G -&gt; adjList[i].firstedge = e;\n    /*e = (EdgeNode *)malloc(sizeof(EdgeNode));\n    e -&gt; adjvex = i;\n    e -&gt;next = G -&gt; adjList[j].firstedge;\n    G -&gt; adjList[j].firstedge = e;*/\n  }\n}\n</code></pre><p>拓扑排序, 求最早发生时间，用于关键路径的计算。</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>int TopologicalSort (GraphAdjList GL) {\n  EdgeNode *e;\n  int i, k, gettop;\n  int top = 0;           //用于栈指针的下标\n  int count = 0;          //用于统计输出顶点的个数\n  int *stack;            //建立栈，将入度为0的顶点入栈\n  stack = (int *)malloc(GL -&gt; numVertexes * sizeof(int));\n  for (i = 0; i &lt; GL -&gt; numVertexes; i++)\n    if (0 == GL -&gt; adjList[i].in)\n    stack[++ top] = i;\n  top2 = 0;              //初始化为0\n  stack2 = (int *)malloc(GL -&gt; numVertexes * sizeof(int));\n  etv = (int *)malloc(GL -&gt; numVertexes * sizeof(int));   //初始化\n  for (i = 0; i &lt; GL -&gt; numVertexes; i++)\n    etv[i] = 0;\n  while (top != 0) {\n    gettop = stack[top --];\n    count ++;\n    stack2[++top2] = gettop;            //将弹出的顶点序号压入拓扑序列栈\n    for (e = GL -&gt; adjList[gettop].firstedge; e; e = e -&gt; next) {\n      k = e -&gt; adjvex;\n      if (! (-- GL -&gt; adjList[k].in)){\n        stack[++top] = k;\n      }\n\n      if ((etv[gettop] + e -&gt; weight) &gt; etv[k]){\n         etv[k] = etv[gettop] + e -&gt; weight;\n      }\n\n    }\n  }\n  if (count &lt; GL -&gt; numVertexes) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n</code></pre><p>求关键路径，GL为有向网，输出GL的各项关键活动</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>void CriticalPath (GraphAdjList GL) {\n  EdgeNode *e;\n  int i, gettop, k, j;\n  int ete, lte;              //声明活动最早发生时间和最迟发生时间\n  TopologicalSort(GL);\n  ltv = (int *)malloc(GL -&gt; numVertexes * sizeof(int));\n  for (i = 0; i &lt; GL -&gt; numVertexes; i++)\n    ltv[i] = etv[GL -&gt; numVertexes -1];\n  while (top2 != 0){\n    gettop = stack2[top2--];\n    //求各事件发生的最迟时间ltv的值\n    for (e = GL -&gt; adjList[gettop].firstedge; e; e = e -&gt; next) {\n      k = e -&gt; adjvex;\n      if (ltv[k] - e -&gt; weight &lt; ltv[gettop])\n        ltv[gettop] = ltv[k] - e -&gt; weight;\n    }\n  }\n    //求ete,lte和关键活动\n    printf(\"\\n关键路径为：\\n\");\n    for (j = 0; j &lt; GL -&gt; numVertexes; j++) {\n       for(e = GL-&gt;adjList[j].firstedge; e; e = e-&gt;next){\n           k = e -&gt; adjvex;\n           ete = etv[j];                   //活动最早发生时间\n           lte = ltv[k] - e -&gt; weight;          //活动最迟发生时间\n           if (ete == lte) {\n              printf(\"&lt;v%c, v%c&gt;  length: %d \\n\", GL -&gt; adjList[j].data, GL -&gt; adjList[k].data, e -&gt; weight);\n           }\n       }\n    }\n}\n</code></pre><p>主入口函数：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>void main() {\n  graphAdjList GL;\n  //初始化\n  CreateALGraph(&amp;GL);\n  CriticalPath (&amp;GL);\n}\n</code></pre><p>测试数据：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>10 13\n0 0\n1 1\n2 1\n3 2\n4 2\n5 1\n6 1\n7 2\n8 1\n9 2\n0 1 3\n0 2 4\n1 4 6\n1 3 5\n2 5 7\n2 3 8\n3 4 3\n4 7 4\n4 6 9\n5 7 6\n6 9 2\n7 8 5\n8 9 3\n</code></pre><p><br></p>', '301', '0', '0', '2017-11-25 01:47:45');
INSERT INTO `articles` VALUES ('12', 'spring boot 单元测试', '本文暂时没有摘要可以显示', 'http://cybsearch.com/wp-content/uploads/2017/09/The-Role-of-Business-Intelligence-in-Small-to-Mid-Sized-Companies-820x400.jpg', '1', '2017-10-10 11:32:19', '<h3>首先，引入相关依赖</h3><p>我们用到了spring-boot-starter-test。 maven 中添加如下依赖：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>&lt;dependency&gt;\n   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n   &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n   &lt;scope&gt;test&lt;/scope&gt;\n&lt;/dependency&gt;\n</code></pre><p>在官网查到它包含的依赖如下：</p><ul><li>AssertJ — A fluent assertion library.</li><li>Hamcrest — A library of matcher objects (also known as constraints or predicates).</li><li>Mockito — A Java mocking framework.</li><li>JSONassert — An assertion library for JSON.</li><li>JsonPath — XPath for JSON.</li></ul><h3>加载spring上下文</h3><p>在测试类前添加注解，否则在执行测试时，报错，提示这个自动注入的属性为空。</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>@RunWith(SpringRunner.class) \n@SpringBootTest\n</code></pre><p>SpringBootTest指定加载应用上下文。 注意：在spring boot1.4.1版本之前，SpringBootTest对应的注解为SpringApplicationConfiguration。</p><h3>测试代码如下：</h3><pre class=\"ql-syntax\" spellcheck=\"false\"><code>@RunWith(SpringRunner.class) \n@SpringBootTest\npublic class TagMapperTest extends BlogApplicationTests{\n    @Autowired\n\n    TagMapper tagMapper;\n\n    @Test\n    public void testInsert() throws Exception {\n        String tagName = \"tagName\"\n        int result = tagMapper.insert(tagName);\n        System.out.print(result); //1\n    }\n}\n</code></pre><p>当然，如果每测试一个方法，就要添加注解是很不方便的，所以可以设置个含有注解的基类，让其他的测试类继承于基类。</p><p>代码改进如下： 基类：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class BlogApplicationTests {\n\n	@Test\n	public void contextLoads() {\n	}\n\n}\n</code></pre><p>测试类：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>public class TagMapperTest extends BlogApplicationTests{\n    @Autowired\n\n    TagMapper tagMapper;\n\n    @Test\n    public void testInsert() throws Exception {\n        String tagName = \"tagName\"\n        int result = tagMapper.insert(tagName);\n        System.out.print(result); //1\n    }\n}\n</code></pre><p>此外，spring-boot-starter-test 还支持controller的测试，此处埋坑，日后再填...</p>', '94', '0', '0', '2017-11-25 00:15:05');
INSERT INTO `articles` VALUES ('13', 'spring boot 简单集成 mybatis', '本文暂时没有摘要可以显示', 'http://cybsearch.com/wp-content/uploads/2017/08/The-5-Hottest-Technologies-for-Your-IT-Career-in-2017-820x400.jpg', '2', '2017-10-10 11:32:28', '<h2>mybatis-spring-boot-starter</h2><p>官方说明：MyBatis Spring-Boot-Starter will help you use MyBatis with Spring Boot 其实就是myBatis看spring boot这么火热也开发出一套解决方案来凑凑热闹,但这一凑确实解决了很多问题，使用起来确实顺畅了许多。mybatis-spring-boot-starter主要有两种解决方案，一种是使用注解解决一切问题，一种是简化后的老传统。</p><p>当然任何模式都需要首先引入mybatis-spring-boot-starter的pom文件,现在最新版本是1.1.1（刚好快到双11了 :)）</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n    &lt;version&gt;1.1.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2>好进入正题</h2><h3>pom.xml</h3><pre class=\"ql-syntax\" spellcheck=\"false\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n	xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n	&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n	&lt;groupId&gt;com.newx&lt;/groupId&gt;\n	&lt;artifactId&gt;blog&lt;/artifactId&gt;\n	&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n	&lt;packaging&gt;jar&lt;/packaging&gt;\n\n	&lt;name&gt;blog&lt;/name&gt;\n	&lt;description&gt;Demo project for Spring Boot&lt;/description&gt;\n\n	&lt;parent&gt;\n		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n		&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n		&lt;version&gt;1.5.7.RELEASE&lt;/version&gt;\n		&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;\n	&lt;/parent&gt;\n\n	&lt;properties&gt;\n		&lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt;\n		&lt;java.version&gt;1.8&lt;/java.version&gt;\n	&lt;/properties&gt;\n\n	&lt;dependencies&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n		&lt;/dependency&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n			&lt;optional&gt;true&lt;/optional&gt;\n		&lt;/dependency&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;\n			&lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;\n			&lt;version&gt;1.3.1&lt;/version&gt;\n		&lt;/dependency&gt;\n\n		&lt;dependency&gt;\n			&lt;groupId&gt;mysql&lt;/groupId&gt;\n			&lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n			&lt;version&gt;5.1.6&lt;/version&gt;\n			&lt;scope&gt;runtime&lt;/scope&gt;\n		&lt;/dependency&gt;\n		&lt;dependency&gt;\n			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n			&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n			&lt;scope&gt;test&lt;/scope&gt;\n		&lt;/dependency&gt;\n	&lt;/dependencies&gt;\n\n	&lt;build&gt;\n		&lt;plugins&gt;\n			&lt;plugin&gt;\n				&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n				&lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n			&lt;/plugin&gt;\n		&lt;/plugins&gt;\n	&lt;/build&gt;\n\n\n&lt;/project&gt;\n</code></pre><h3>application.properties 添加相关配置</h3><pre class=\"ql-syntax\" spellcheck=\"false\"><code>server.port=9000\nmybatis.config-location=classpath:mybatis-config.xml\nmybatis.mapper-locations=classpath:mapper/*Mapper.xml\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.datasource.url=jdbc:mysql://localhost:3306/blog?characterEncoding=utf-8\nspring.datasource.username=root\nspring.datasource.password=ddbb0120\n</code></pre><p>springboot会自动加载spring.datasource.*相关配置，数据源就会自动注入到sqlSessionFactory中，sqlSessionFactory会自动注入到Mapper中，对了你一切都不用管了，直接拿起来使用就行了。</p><p>在启动类中添加对mapper包扫描@MapperScan</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>@RestController\n@EnableAutoConfiguration\n@MapperScan(\"com.newx.blog.dao\")\n@SpringBootApplication(exclude={DataSourceAutoConfiguration.class})\n\npublic class BlogApplication {\n	@RequestMapping(\"/\")\n	String home() {\n		return \"Hello World!\";\n	}\n	public static void main(String[] args) {\n		SpringApplication.run(BlogApplication.class, args);\n	}\n}\n</code></pre><p>或者直接在Mapper类上面添加注解@Mapper,建议使用上面那种，不然每个mapper加个注解也挺麻烦的</p><h3>mybatis-config.xml 配置</h3><p>在idea下 右键resources , new mybatis-config, 文件名：new mybatis-config.xml</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE configuration\n        PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\"\n        \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;\n&lt;configuration&gt;\n\n    &lt;settings&gt;\n        &lt;!-- Globally enables or disables any caches configured in any dao under this configuration --&gt;\n        &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt;\n        &lt;!-- Sets the number of seconds the driver will wait for a response from the database --&gt;\n        &lt;setting name=\"defaultStatementTimeout\" value=\"3000\"/&gt;\n        &lt;!-- Enables automatic mapping from classic database column names A_COLUMN to camel case classic Java property names aColumn --&gt;\n        &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt;\n        &lt;!-- Allows JDBC support for generated keys. A compatible driver is required.\n        This setting forces generated keys to be used if set to true,\n         as some drivers deny compatibility but still work --&gt;\n        &lt;setting name=\"useGeneratedKeys\" value=\"true\"/&gt;\n    &lt;/settings&gt;\n\n    &lt;!-- Continue going here --&gt;\n\n&lt;/configuration&gt;\n</code></pre><h3>编写entity</h3><pre class=\"ql-syntax\" spellcheck=\"false\"><code>package com.newx.blog.entity;\n\n/**\n * Created by home on 2017/9/20.\n */\npublic class TagEntity {\n    private int tagId;\n    private String tagName;\n    private int remove;\n\n    public int getTagId() {\n        return tagId;\n    }\n\n    public void setTagId(int tagId) {\n        this.tagId = tagId;\n    }\n\n    public String getTagName() {\n        return tagName;\n    }\n\n    public void setTagName(String tagName) {\n        this.tagName = tagName;\n    }\n\n    public int getRemove() {\n        return remove;\n    }\n\n    public void setRemove(int remove) {\n        this.remove = remove;\n    }\n}\n</code></pre><h3>添加mapper 文件</h3><pre class=\"ql-syntax\" spellcheck=\"false\"><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;\n\n&lt;mapper namespace=\"com.newx.blog.dao.TagMapper\" &gt;\n    &lt;insert id=\"insert\" parameterType=\"com.newx.blog.entity.TagEntity\"&gt;\n        INSERT INTO tag (tagId, tagName)\n        VALUES(#{tagId}, #{tagName})\n    &lt;/insert&gt;\n    &lt;select id=\"selectAll\" resultType=\"hashmap\"&gt;\n        SELECT * FROM tag\n    &lt;/select&gt;\n&lt;/mapper&gt;\n</code></pre><h3>编写dao层代码</h3><pre class=\"ql-syntax\" spellcheck=\"false\"><code>public interface TagMapper {\n    void insert(TagEntity tagEntity);\n    List&lt;HashMap&lt;String, Object&gt;&gt; selectAll();\n}\n</code></pre><h3>编写controller</h3><pre class=\"ql-syntax\" spellcheck=\"false\"><code>@RestController\n//@RequestMapping(value = \"/tag\")\npublic class TagController {\n    @Autowired\n    private TagMapper tagMapper;\n\n    @RequestMapping(value = \"/tag\", method = RequestMethod.GET)\n    public List&lt;HashMap&lt;String, Object&gt;&gt; getTags() {\n        return tagMapper.selectAll();\n    }\n}\n</code></pre><p><br></p>', '84', '0', '0', '2017-11-25 00:34:54');
INSERT INTO `articles` VALUES ('37', '图的深度和广度遍历时间复杂度分析。', '本文暂时没有摘要可以显示', 'https://img.c7sky.com/2017/03/26/playing-morse-code-web-audio-api-banner.jpg', '3', '2017-10-10 11:31:52', '<h1>广度优先搜索：</h1><h2>邻接表：</h2><p><img src=\"http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1506530017406blog.jpg?Expires=1821890012&amp;OSSAccessKeyId=LTAIw9QfPaWovM1p&amp;Signature=UDztXZrbcbuHKnlobOhgwqQgwAU%3D\"></p><p>想遍历一个图，就得将图的每个顶点都走一遍，而从一个顶点到另一个顶点（比如从v1 -&gt; v2），必定要经过将他们相连的边（e12）。</p><p>对于广度优先搜索，大致过程是：</p><ol><li>遍历顶点数组（共n个顶点），</li><li>对每个顶点的邻接节点进行遍历（每个顶点的邻接节点分别有e1,e2,e3...ev 个，加起来一共是m个）</li></ol><blockquote>注意：由于visit数组的存在，已访问过的节点已经做了标记，所以不用重新遍历一个顶点的邻接节点去寻找未访问的节点。</blockquote><p>执行时可以简单描述为： v1 + (从v1出去的边数) ＋ v2 ＋ (从v2出去的边数) ＋ v3 ＋ … ＋ vn ＋ (从vn出去的边数)</p><p>变换为： (v1 + v2 + … + vn) + {(从v1出去的边数) + (从v2出去的边数) + … + (从vn出去的边数) }</p><p>前一部分是O(n)，后一部分是O(m)</p><p>所以，综上，用邻接表存储的图的BFS时间复杂度是O(n + m)。</p><h2>邻接矩阵：</h2><p>未完待续。。。</p>', '105', '0', '0', '2017-11-25 00:32:45');
INSERT INTO `articles` VALUES ('43', '图的关键路径算法，c语言实现。43', '本文暂时没有摘要可以显示', 'https://img.c7sky.com/2017/05/20/mp3tag-douban-web-source-banner-1.jpg', '3', '2017-10-01 20:46:05', '<p>我们以下图为例子：</p><p><img src=\"http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1506602874199blog.jpg?Expires=1821962867&amp;OSSAccessKeyId=LTAIw9QfPaWovM1p&amp;Signature=OUYkSY%2FoQonhzR0aVmmcU2EO%2FU8%3D\" class=\"\"></p><p><br></p><blockquote>图来自《大话数据结构》</blockquote><p>本算法基于邻接表来实现，首先定义一些基本的变量，与结构体</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>#include &lt;stdio.h&gt;\n#define MAXVEX 65535\n#define INFINITY 65535\nint *etv, *ltv;     //事件最早发生时间和最迟发生时间数组；\nint *stack2;        //用于存储拓扑序列的栈\nint top2;           //用于stack2的指针\n\ntypedef struct EdgeNode {   //边表节点\n  int adjvex;               //邻接点域，存储该顶点对应的下标\n  int weight;                //存储权值\n  struct EdgeNode *next;      //链域，指向下一个邻接点\n}EdgeNode;\n\ntypedef struct VextexNode{   // 顶点表节点\n  int in;                    // 顶点入度\n  int data;                     // 顶点域存储顶点信息\n  EdgeNode * firstedge;       // 边表头指针\n}VertexNode, AdjList[MAXVEX];\n\ntypedef struct {            // 定义图\n  AdjList adjList;\n  int numVertexes, numEdges;\n}graphAdjList, *GraphAdjList;\n</code></pre><p>初始化图：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>CreateALGraph(GraphAdjList G) {\n  int j, k, i, quan;\n  EdgeNode* e;\n  printf(\"请输入顶点数和边数\\n\");\n  scanf(\"%d %d\", &amp;G -&gt; numVertexes, &amp;G -&gt; numEdges);\n  fflush(stdin);\n  for (i = 0; i &lt; G -&gt; numVertexes; i++) {\n    printf(\"请输入%d个元素和入度\\n\", i);\n    scanf(\"%c %d\", &amp;G -&gt; adjList[i].data, &amp;G -&gt; adjList[i].in);   //输入顶点信息\n    fflush(stdin);\n    G -&gt; adjList[i].firstedge = NULL;    //边表置空\n  }\n  for (k = 0; k &lt; G -&gt; numEdges; k++) {\n    printf(\"请输入边的起点序号，终点序号以及权重\\n\");\n    scanf(\"%d %d %d\", &amp;i, &amp;j, &amp;quan);\n    fflush(stdin);\n    e = (EdgeNode *)malloc(sizeof(EdgeNode));\n    e -&gt; adjvex = j;\n    e -&gt; weight = quan;\n    e -&gt; next = G -&gt; adjList[i].firstedge;\n    G -&gt; adjList[i].firstedge = e;\n    /*e = (EdgeNode *)malloc(sizeof(EdgeNode));\n    e -&gt; adjvex = i;\n    e -&gt;next = G -&gt; adjList[j].firstedge;\n    G -&gt; adjList[j].firstedge = e;*/\n  }\n}\n</code></pre><p>拓扑排序, 求最早发生时间，用于关键路径的计算。</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>int TopologicalSort (GraphAdjList GL) {\n  EdgeNode *e;\n  int i, k, gettop;\n  int top = 0;           //用于栈指针的下标\n  int count = 0;          //用于统计输出顶点的个数\n  int *stack;            //建立栈，将入度为0的顶点入栈\n  stack = (int *)malloc(GL -&gt; numVertexes * sizeof(int));\n  for (i = 0; i &lt; GL -&gt; numVertexes; i++)\n    if (0 == GL -&gt; adjList[i].in)\n    stack[++ top] = i;\n  top2 = 0;              //初始化为0\n  stack2 = (int *)malloc(GL -&gt; numVertexes * sizeof(int));\n  etv = (int *)malloc(GL -&gt; numVertexes * sizeof(int));   //初始化\n  for (i = 0; i &lt; GL -&gt; numVertexes; i++)\n    etv[i] = 0;\n  while (top != 0) {\n    gettop = stack[top --];\n    count ++;\n    stack2[++top2] = gettop;            //将弹出的顶点序号压入拓扑序列栈\n    for (e = GL -&gt; adjList[gettop].firstedge; e; e = e -&gt; next) {\n      k = e -&gt; adjvex;\n      if (! (-- GL -&gt; adjList[k].in)){\n        stack[++top] = k;\n      }\n\n      if ((etv[gettop] + e -&gt; weight) &gt; etv[k]){\n         etv[k] = etv[gettop] + e -&gt; weight;\n      }\n\n    }\n  }\n  if (count &lt; GL -&gt; numVertexes) {\n    return 0;\n  } else {\n    return 1;\n  }\n}\n</code></pre><p>求关键路径，GL为有向网，输出GL的各项关键活动</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>void CriticalPath (GraphAdjList GL) {\n  EdgeNode *e;\n  int i, gettop, k, j;\n  int ete, lte;              //声明活动最早发生时间和最迟发生时间\n  TopologicalSort(GL);\n  ltv = (int *)malloc(GL -&gt; numVertexes * sizeof(int));\n  for (i = 0; i &lt; GL -&gt; numVertexes; i++)\n    ltv[i] = etv[GL -&gt; numVertexes -1];\n  while (top2 != 0){\n    gettop = stack2[top2--];\n    //求各事件发生的最迟时间ltv的值\n    for (e = GL -&gt; adjList[gettop].firstedge; e; e = e -&gt; next) {\n      k = e -&gt; adjvex;\n      if (ltv[k] - e -&gt; weight &lt; ltv[gettop])\n        ltv[gettop] = ltv[k] - e -&gt; weight;\n    }\n  }\n    //求ete,lte和关键活动\n    printf(\"\\n关键路径为：\\n\");\n    for (j = 0; j &lt; GL -&gt; numVertexes; j++) {\n       for(e = GL-&gt;adjList[j].firstedge; e; e = e-&gt;next){\n           k = e -&gt; adjvex;\n           ete = etv[j];                   //活动最早发生时间\n           lte = ltv[k] - e -&gt; weight;          //活动最迟发生时间\n           if (ete == lte) {\n              printf(\"&lt;v%c, v%c&gt;  length: %d \\n\", GL -&gt; adjList[j].data, GL -&gt; adjList[k].data, e -&gt; weight);\n           }\n       }\n    }\n}\n</code></pre><p>主入口函数：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>void main() {\n  graphAdjList GL;\n  //初始化\n  CreateALGraph(&amp;GL);\n  CriticalPath (&amp;GL);\n}\n</code></pre><p>测试数据：</p><pre class=\"ql-syntax\" spellcheck=\"false\"><code>10 13\n0 0\n1 1\n2 1\n3 2\n4 2\n5 1\n6 1\n7 2\n8 1\n9 2\n0 1 3\n0 2 4\n1 4 6\n1 3 5\n2 5 7\n2 3 8\n3 4 3\n4 7 4\n4 6 9\n5 7 6\n6 9 2\n7 8 5\n8 9 3\n</code></pre><p><br></p>', '73', '0', '0', '2017-11-25 00:13:52');
INSERT INTO `articles` VALUES ('56', 'java 日期类转换', '本文暂时没有摘要可以显示', 'https://img.c7sky.com/2017/02/01/how-to-create-direction-aware-css-only-hover-effects-banner.png', '2', '2017-10-10 11:31:45', '<pre class=\"ql-syntax hljs processing\" spellcheck=\"false\"><span class=\"hljs-keyword\">public</span> ServerResponse&lt;<span class=\"hljs-keyword\">HashMap</span>&lt;<span class=\"hljs-keyword\">String</span>, <span class=\"hljs-keyword\">Object</span>&gt;&gt; getCurrentExamination(<span class=\"hljs-built_in\">int</span> paperId) <span class=\"hljs-keyword\">throws</span> ParseException, IOException {\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">HashMap</span>&lt;<span class=\"hljs-keyword\">String</span>, <span class=\"hljs-keyword\">Object</span>&gt; result = paperMapper.getCurrentExamination(paperId);\n&nbsp;&nbsp;&nbsp;&nbsp;ObjectMapper objectMapper = <span class=\"hljs-keyword\">new</span> ObjectMapper();\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span> (result == <span class=\"hljs-keyword\">null</span>) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span> ServerResponse.createByErrorMessage(<span class=\"hljs-string\">\"获取失败\"</span>);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;&nbsp;&nbsp;SimpleDateFormat simpleDateFormat = <span class=\"hljs-keyword\">new</span> SimpleDateFormat(<span class=\"hljs-string\">\"yy-MM-dd HH:mm:ss\"</span>);\n\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">//格式化时间戳</span>\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">String</span> dateTime_String = simpleDateFormat.format(result.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-string\">\"start_time\"</span>));\n&nbsp;&nbsp;&nbsp;&nbsp;Date dateTime_Date = simpleDateFormat.parse(dateTime_String);\n&nbsp;&nbsp;&nbsp;&nbsp;result.put(<span class=\"hljs-string\">\"start_time\"</span>, dateTime_String);\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-comment\">//时间加上2分钟 Integer.parseInt(</span>\n&nbsp;&nbsp;&nbsp;&nbsp;Date deadTime_Date = <span class=\"hljs-keyword\">new</span> Date(dateTime_Date.getTime() + (<span class=\"hljs-built_in\">int</span>)result.<span class=\"hljs-built_in\">get</span>(<span class=\"hljs-string\">\"last_time\"</span>)*<span class=\"hljs-number\">60000</span>);\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;Date now = <span class=\"hljs-keyword\">new</span> Date();\n\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-built_in\">int</span> dateCompare = now.compareTo(deadTime_Date);\n&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">if</span> (dateCompare &lt;= <span class=\"hljs-number\">0</span>) {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.<span class=\"hljs-built_in\">println</span>(<span class=\"hljs-string\">\"时间剩余\"</span>);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">long</span> interval = (deadTime_Date.getTime() - now.getTime()) / <span class=\"hljs-number\">60000</span>;\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result.put(<span class=\"hljs-string\">\"rest_time\"</span>, interval);\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span> ServerResponse.createBySuccess(result);\n&nbsp;&nbsp;&nbsp;&nbsp;}<span class=\"hljs-keyword\">else</span> {\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class=\"hljs-keyword\">return</span>&nbsp;ServerResponse.createByErrorMessage(<span class=\"hljs-string\">\"当前考试已超时\"</span>);\n&nbsp;&nbsp;&nbsp;&nbsp;}\n\n&nbsp;&nbsp;}\n</pre>', '114', '0', '0', '2017-11-25 01:48:00');
INSERT INTO `articles` VALUES ('57', '中序线索二叉树的实现', '本文暂时没有摘要可以显示', 'https://img.c7sky.com/2017/08/17/lazy-loading-images-using-intersection-observer-banner.png', '3', '2017-10-10 11:35:05', '<p>常见的二叉树存储结构如下所示：</p><p><img src=\"http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1506785164690qq%E6%88%AA%E5%9B%BE20170930231806.png?Expires=1822145160&amp;OSSAccessKeyId=LTAIw9QfPaWovM1p&amp;Signature=nNi%2BkYIzDv7w0k9haMYQPj2qegw%3D\" alt=\"image\"></p><p>它包含许多由^表示的空指针，浪费了不少空间。</p><p>而线索二叉树则将所有的空指针都利用起来，用于指向某个叶子节点的前驱或者后继，从而提高了二叉树遍历的效率，如图：&nbsp;<img src=\"http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1506785266930qq%E6%88%AA%E5%9B%BE20170930231901.png?Expires=1822145261&amp;OSSAccessKeyId=LTAIw9QfPaWovM1p&amp;Signature=NY5Jcl8e1Bu9NDqoVu42qOUaKhw%3D\" alt=\"image\"></p><p>可以明显看出一些特点：</p><ol><li>每个节点除了指针域，还多了两个存有0，1的标志域，用于标记空指针是指向左右孩子，还是指向前驱或后继。0表示指向左孩子或者右孩子，左边的标志位1表示指向前驱，右边的标志域1表示指向后继</li><li>在二叉树顶部，加上了个空的节点，左孩子指向树的根节点（图中序号1），右孩子指向中序遍历的最后一个节点（图中序号2）。</li><li>中序遍历的第一个节点指向头结点（图中序号3，H-&gt;头结点），中序遍历的最后一个节点指向头结点（图中序号4，G-&gt;头结点） 这样的结果就是，我们遍历树的时候，其实就是操作双向链表</li></ol><p>以下是具体实现过程</p><h4>首先定义线索二叉树的存储结构</h4><pre class=\"ql-syntax hljs cpp\" spellcheck=\"false\"><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">include</span> <span class=\"hljs-meta-string\">&lt;stdio.h&gt;</span></span>\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">enum</span> {Link, Thread} PointerTag; \n<span class=\"hljs-comment\">//全局变量，刚刚访问过的节点</span>\nBitThrTree pre;  <span class=\"hljs-comment\">//BitThrNode * pre</span>\n\n<span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">BitThrNode</span> {</span>\n  <span class=\"hljs-keyword\">char</span> data;\n  <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">BitThrNode</span> *<span class=\"hljs-title\">lchild</span>, *<span class=\"hljs-title\">rchild</span>;</span>\n  PointerTag ltag; <span class=\"hljs-comment\">// 左标志位，存放 Link 或者 Thred</span>\n  PointerTag rtag; <span class=\"hljs-comment\">// 右标志位，存放 Link 或者 Thred</span>\n} BitThrNode, *BitThrTree;\n</pre><p>其中包含2个枚举变量，一个全局指针变量pre：</p><ul><li>Link == 0 标识 指针域 指向左右孩子</li><li>Thread == 1 标识 指针域 指向前驱或者后继节点</li><li>pre 始终指向刚刚被访问的节点，从最开始指向头结点，到最后指向中序遍历的最后一个节点</li></ul><h4>创建二叉树</h4><pre class=\"ql-syntax hljs livescript\" spellcheck=\"false\"><span class=\"hljs-regexp\">// 按照前序遍历的方式输入数据，创建一颗二叉树\n//</span> BitThrTree *T相当于BitThrNode **T,指针的指针，对指针进行初始化，传指针的地址\nCreateBiThrTree (BitThrTree *T) {\n  char c;\n  scanf(<span class=\"hljs-string\">\"%c\"</span>, &amp;c);\n  <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-string\">\' \'</span> == c) {\n    *T = NULL; \n  } <span class=\"hljs-keyword\">else</span> {\n    *T = (BitThrNode *)malloc(sizeof(BitThrNode));\n    <span class=\"hljs-function\"><span class=\"hljs-params\">(*T)</span> -&gt;</span> data = c;\n    CreateBiThrTree<span class=\"hljs-function\"><span class=\"hljs-params\">(&amp;(*T) -&gt; lchild)</span>;\n    <span class=\"hljs-title\">CreateBiThrTree</span><span class=\"hljs-params\">(&amp;(*T) -&gt; rchild)</span>;\n    // 同时初始化标志域为 0\n    <span class=\"hljs-params\">(*T)</span> -&gt;</span> ltag = Link;\n    <span class=\"hljs-function\"><span class=\"hljs-params\">(*T)</span> -&gt;</span> rtag = Link;\n   }\n}\n</pre><h4>中序遍历线索化</h4><p>线索化的实质就是将空指针指向前驱或者后继。前驱和后继信息，只有在遍历二叉树的时候才得到，所以我们要在遍历的过程中，动态的修改空指针的指向。</p><pre class=\"ql-syntax hljs xl\" spellcheck=\"false\"><span class=\"hljs-comment\">//中序遍历线索化</span>\nInThreading (InThreading p) {\n  <span class=\"hljs-keyword\">if</span> (p) {\n    <span class=\"hljs-comment\">// 递归找到中序遍历开始的第一个节点(本例子中的H）</span>\n    I<span class=\"hljs-function\"><span class=\"hljs-title\">nThreading</span>(p -&gt;</span> lchild);  \n    \n    <span class=\"hljs-comment\">// 左孩子为空，指向前驱，完成前驱节点线索化。</span>\n    <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (! p -&gt;</span> lchild) { \n        <span class=\"hljs-function\"><span class=\"hljs-title\">p</span> -&gt;</span> lTag = Thread; \n        <span class=\"hljs-function\"><span class=\"hljs-title\">p</span> -&gt;</span> lchild = pre;\n    }\n    <span class=\"hljs-comment\">// 前驱的右孩子为空，指向后继，即pre的后继节点p。</span>\n    <span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (! pre -&gt;</span> rchild) { \n        <span class=\"hljs-function\"><span class=\"hljs-title\">pre</span> -&gt;</span> rTag = Thread;\n        <span class=\"hljs-function\"><span class=\"hljs-title\">pre</span> -&gt;</span> rchild = p;\n    }\n    \n    pre = p;\n    \n    I<span class=\"hljs-function\"><span class=\"hljs-title\">nThreading</span>(p -&gt;</span> rchild);\n  }\n}\n</pre><p>注意，pre始终指向p节点，当p节点变化的时候，pre也相应的跟着改变。</p><p>以上代码包含下面这段：</p><pre class=\"ql-syntax hljs xl\" spellcheck=\"false\"><span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (! p -&gt;</span> lchild) { \n    <span class=\"hljs-function\"><span class=\"hljs-title\">p</span> -&gt;</span> lTag = Thread; \n    <span class=\"hljs-comment\">// 第一次符合条件的时候，中序遍历的第一个节点指向头结点（图中序号4）</span>\n    <span class=\"hljs-function\"><span class=\"hljs-title\">p</span> -&gt;</span> lchild = pre;\n}\n<span class=\"hljs-function\"><span class=\"hljs-title\">if</span> (! pre -&gt;</span> rchild) { \n    <span class=\"hljs-function\"><span class=\"hljs-title\">pre</span> -&gt;</span> rTag = Thread;\n    <span class=\"hljs-function\"><span class=\"hljs-title\">pre</span> -&gt;</span> rchild = p;\n}\npre = p;\n</pre><p>若将它替换为 printf(\"%c\", p-&gt;data)则是打印该节点，而现在它完成了线索化的任务。</p><ol><li>if (! p -&gt; lchild) 表示某节点左指针域为空，则将pre赋值给p-&gt;lchild。</li><li>if (! pre -&gt; rchild) 表示如果前驱节点的右指针为空，则可以利用起来去指向后继节点p。</li></ol><p>这里就有个问题了，为什么是判断 pre -&gt; rchild 是否为空，而不是 p -&gt; rchild 是否为空？ 虽然我们可以判断出 p -&gt; rchild 是否为空，但是由于中序遍历的特点，我们现在还不知道p的后继节点。比如我们遍历到叶子节点H的时候，我们并不知道H之后的节点是哪个，所以这个方案行不通。</p><p>但是，pre节点，已经访问过它的后继节点了 ( •̀ ω •́ )y ，也就是P 。 所以在这里去判断pre的右孩子若是为空，则pre的后继就指向P。</p><p>接下来我们要去找下一个p了，所以别忘记把当前的P保存在pre中，然后再继续向右构建线索。</p><p>以DHI节点为例子，假设此时P指向的H节点</p><p><img src=\"http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1506818693343chu%256l%2884%28%29v%40tolpx5p%29fx.png?Expires=1822178683&amp;OSSAccessKeyId=LTAIw9QfPaWovM1p&amp;Signature=dq13NdxxEGv5tYfNdLRaDMDLEwU%3D\" alt=\"image\"></p><ol><li>P的左右子树都为空，所以H左指针指向前驱D。</li><li>但是pre节点（D)的右子树不为空，跳过if (! pre -&gt; rchild)</li><li>因为即将要进行右子树的线索化，所以pre 指向当前的P（节点H）</li><li>向右遍历P节点，发现是空，当前函数指向完毕，进入递归的上一层函数</li><li>此时P指向的是D，在这一层函数中，InThreading(p -&gt; lchild); 已执行完毕，且P的左孩子不为空，跳过if (! pre -&gt; lchild)。</li><li>pre 此时指向H，且H的右孩子为空，所以可以让pre指向p，也就完成了H节点指向D节点。</li><li>后面过程类似，就不说了</li></ol><p>中序遍历线索化的函数已经有了，那么怎么调用呢？我们需要一个头结点，来初始化pre。</p><h4>添加头结点，并调用InThreading函数线索化二叉树。</h4><pre class=\"ql-syntax hljs livescript\" spellcheck=\"false\">InOrderThreading (BitThrTree *P, BitThrTree T) {\n  *P = (BitThrTree)malloc(sizeof(BitThrNode));\n  <span class=\"hljs-function\"><span class=\"hljs-params\">(*P)</span> -&gt;</span> ltag = Link;\n  <span class=\"hljs-function\"><span class=\"hljs-params\">(*P)</span> -&gt;</span> rtag = Thread;\n  <span class=\"hljs-function\"><span class=\"hljs-params\">(*P)</span> -&gt;</span> rchild = *P;\n  <span class=\"hljs-keyword\">if</span> ( ! T ) {\n    <span class=\"hljs-function\"><span class=\"hljs-params\">(*P)</span> -&gt;</span> lchild = *P;\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-function\"><span class=\"hljs-params\">(*P)</span> -&gt;</span> lchild = T;\n    pre = *P;\n    InThreading(T);  <span class=\"hljs-regexp\">// 中序线索后，pre已指向最后一个节点\n    pre -&gt; rtag = Thread;  //</span> 对最后一个节点的右标志设为<span class=\"hljs-number\">1</span>，表示指向后继节点\n    pre<span class=\"hljs-function\"> -&gt;</span> rchild = *P; <span class=\"hljs-regexp\">// 最后一个节点，指向头节点P\n    (*P) -&gt; rchild = pre; //</span> 头节点P的后继指向最后一个节点pre。\n  }\n}\n</pre><p>正如上面提到的，头节点左孩子指向树的根节点（图中序号1，H-&gt;头结点），右孩子指向中序遍历的最后一个节点（图中序号2，H-&gt;头结点）。</p><p>中序遍历的第一个节点指向头结点（图中序号3，H-&gt;头结点），中序遍历的最后一个节点指向头结点（图中序号4，G-&gt;头结点）&nbsp;<img src=\"http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1506785266930qq%E6%88%AA%E5%9B%BE20170930231901.png?Expires=1822145261&amp;OSSAccessKeyId=LTAIw9QfPaWovM1p&amp;Signature=NY5Jcl8e1Bu9NDqoVu42qOUaKhw%3D\" alt=\"image\"></p><h4>中序遍历二叉树，非递归</h4><pre class=\"ql-syntax hljs rust\" spellcheck=\"false\"><span class=\"hljs-comment\">//中序遍历二叉树，非递归</span>\nvoid InOrderTraverse ( BitThrTree T) {  <span class=\"hljs-comment\">// T 为线索化的带头结点的二叉树。</span>\n  BitThrTree P;\n  P = T -&gt; lchild; <span class=\"hljs-comment\">//  P 指向根节点。</span>\n  <span class=\"hljs-keyword\">while</span> ( P != T) {  <span class=\"hljs-comment\">// 空树，或者遍历结束的时候</span>\n    <span class=\"hljs-keyword\">while</span> (P -&gt; ltag == Link) { <span class=\"hljs-comment\">//找到最左边的叶子节点</span>\n        P = P -&gt; lchild;\n    }\n    printf(<span class=\"hljs-string\">\"%c\"</span>, P -&gt; data);\n    <span class=\"hljs-keyword\">while</span> (P -&gt; rtag == Thread &amp;&amp; P -&gt; rchild != T) { <span class=\"hljs-comment\">// 当线索存在，则直接跟着线索向后遍历。回到其根节点</span>\n      P = P -&gt; rchild;\n      printf(<span class=\"hljs-string\">\"%c\"</span>, P -&gt; data);\n    }\n    P = P -&gt; rchild; <span class=\"hljs-comment\">// 回到根节点后，后续节点的线索不存在，则访问右节点</span>\n  }\n}\n</pre><h4>入口函数</h4><pre class=\"ql-syntax hljs mipsasm\" spellcheck=\"false\">int main() {\n  <span class=\"hljs-keyword\">BitThrTree </span>P, T = NULL<span class=\"hljs-comment\">;</span>\n  CreateBiThrTree( &amp;T )<span class=\"hljs-comment\">;</span>\n  InOrderThreading(&amp;P, T)<span class=\"hljs-comment\">;</span>\n  printf(<span class=\"hljs-string\">\"中序遍历输出的结果为:\"</span>)<span class=\"hljs-comment\">;</span>\n  InOrderTraverse(P)<span class=\"hljs-comment\">;</span>\n  return <span class=\"hljs-number\">0</span><span class=\"hljs-comment\">;</span>\n}\n</pre><p>测试数据： 1#23##4###</p><p>测试结果： 中序遍历输出的结果为:1324</p>', '126', '0', '0', '2017-11-25 00:37:33');
INSERT INTO `articles` VALUES ('63', 'test', '本文暂时没有摘要可以显示', 'http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1507032421562temp.jpg?Expires=1822392418&OSSAccessKeyId=LTAIw9QfPaWovM1p&Signature=qKZp9UL1CY9aVX3%2Bzi1Q%2FrKyU9w%3D', '3', '2017-10-03 20:07:42', '<p>notignsga</p>', '131', '0', '0', '2017-11-25 00:13:53');
INSERT INTO `articles` VALUES ('64', '测试11111111', '本文暂时没有摘要可以显示', 'http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1507034450818temp.jpg?Expires=1822394445&OSSAccessKeyId=LTAIw9QfPaWovM1p&Signature=aQm7NcqLUs2Z5gMUzrwybKUeTXI%3D', '3', '2017-10-03 20:41:59', '<h2>么么哒~</h2><p><img src=\"http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1507034491011tt.png?Expires=1822394487&amp;OSSAccessKeyId=LTAIw9QfPaWovM1p&amp;Signature=Qeio%2BOR9RWes0c%2FRS24m7iZ2ytA%3D\" class=\"\"></p><p><br></p><pre class=\"ql-syntax hljs javascript\" spellcheck=\"false\">public ServerResponse&lt;HashMap&lt;<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">Object</span>&gt;&gt; getCurrentExamination(int paperId) throws ParseException, IOException {\n        HashMap&lt;<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">Object</span>&gt; result = paperMapper.getCurrentExamination(paperId);\n        ObjectMapper objectMapper = <span class=\"hljs-keyword\">new</span> ObjectMapper();\n        <span class=\"hljs-keyword\">if</span> (result == <span class=\"hljs-literal\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> ServerResponse.createByErrorMessage(<span class=\"hljs-string\">\"获取失败\"</span>);\n        }\n\n        SimpleDateFormat simpleDateFormat = <span class=\"hljs-keyword\">new</span> SimpleDateFormat(<span class=\"hljs-string\">\"yy-MM-dd HH:mm:ss\"</span>);\n\n        <span class=\"hljs-comment\">//格式化时间戳</span>\n        <span class=\"hljs-built_in\">String</span> dateTime_String = simpleDateFormat.format(result.get(<span class=\"hljs-string\">\"start_time\"</span>));\n        <span class=\"hljs-built_in\">Date</span> dateTime_Date = simpleDateFormat.parse(dateTime_String);\n        result.put(<span class=\"hljs-string\">\"start_time\"</span>, dateTime_String);\n\n\n        <span class=\"hljs-comment\">//时间加上2分钟 Integer.parseInt(</span>\n        <span class=\"hljs-built_in\">Date</span> deadTime_Date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(dateTime_Date.getTime() + (int)result.get(<span class=\"hljs-string\">\"last_time\"</span>)*<span class=\"hljs-number\">60000</span>);\n\n\n        <span class=\"hljs-built_in\">Date</span> now = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>();\n\n        int dateCompare = now.compareTo(deadTime_Date);\n        <span class=\"hljs-keyword\">if</span> (dateCompare &lt;= <span class=\"hljs-number\">0</span>) {\n            System.out.println(<span class=\"hljs-string\">\"时间剩余\"</span>);\n            long interval = (deadTime_Date.getTime() - now.getTime()) / <span class=\"hljs-number\">60000</span>;\n            result.put(<span class=\"hljs-string\">\"rest_time\"</span>, interval);\n            <span class=\"hljs-keyword\">return</span> ServerResponse.createBySuccess(result);\n        }<span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span>  ServerResponse.createByErrorMessage(<span class=\"hljs-string\">\"当前考试已超时\"</span>);\n        }\n\n    }\n</pre><p><br></p><p><br></p><p><br></p><p><br></p><p><br></p>', '98', '0', '0', '2017-11-24 17:20:08');
INSERT INTO `articles` VALUES ('65', '最终测试', '本文暂时没有摘要可以显示', 'http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1507035317445temp.jpg?Expires=1822395310&OSSAccessKeyId=LTAIw9QfPaWovM1p&Signature=PaRZ0St05hQZ5FdKEFG9tiS%2FSRs%3D', '3', '2017-10-03 20:57:25', '<h2>标题</h2><p class=\"ql-align-center\"><br></p><p class=\"ql-align-center\"><strong><em>1</em></strong></p><p class=\"ql-align-center\"><strong><em>2</em></strong></p><p class=\"ql-align-right\">2</p><p class=\"ql-align-right\">3</p><blockquote>3</blockquote><blockquote>4</blockquote><blockquote>3</blockquote><blockquote>53</blockquote><ol><li>45</li><li>23</li><li>54</li></ol><p><br></p><ul><li>45</li><li>23</li><li>54</li></ul><p><a href=\"aa\" target=\"_blank\">aa</a></p><p><br></p><p><img src=\"http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/15070354315093c85c77e584d8a616bf6c42018698baee7d474703cf4af7d327839e6f528530d.jpg?Expires=1822395424&amp;OSSAccessKeyId=LTAIw9QfPaWovM1p&amp;Signature=szZ%2B4XrRo09RkAUAybISqKIjR4g%3D\"></p><p><br></p><pre class=\"ql-syntax hljs javascript\" spellcheck=\"false\">public ServerResponse&lt;HashMap&lt;<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">Object</span>&gt;&gt; getCurrentExamination(int paperId) throws ParseException, IOException {\n        HashMap&lt;<span class=\"hljs-built_in\">String</span>, <span class=\"hljs-built_in\">Object</span>&gt; result = paperMapper.getCurrentExamination(paperId);\n        ObjectMapper objectMapper = <span class=\"hljs-keyword\">new</span> ObjectMapper();\n        <span class=\"hljs-keyword\">if</span> (result == <span class=\"hljs-literal\">null</span>) {\n            <span class=\"hljs-keyword\">return</span> ServerResponse.createByErrorMessage(<span class=\"hljs-string\">\"获取失败\"</span>);\n        }\n\n        SimpleDateFormat simpleDateFormat = <span class=\"hljs-keyword\">new</span> SimpleDateFormat(<span class=\"hljs-string\">\"yy-MM-dd HH:mm:ss\"</span>);\n\n        <span class=\"hljs-comment\">//格式化时间戳</span>\n        <span class=\"hljs-built_in\">String</span> dateTime_String = simpleDateFormat.format(result.get(<span class=\"hljs-string\">\"start_time\"</span>));\n        <span class=\"hljs-built_in\">Date</span> dateTime_Date = simpleDateFormat.parse(dateTime_String);\n        result.put(<span class=\"hljs-string\">\"start_time\"</span>, dateTime_String);\n\n\n        <span class=\"hljs-comment\">//时间加上2分钟 Integer.parseInt(</span>\n        <span class=\"hljs-built_in\">Date</span> deadTime_Date = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>(dateTime_Date.getTime() + (int)result.get(<span class=\"hljs-string\">\"last_time\"</span>)*<span class=\"hljs-number\">60000</span>);\n\n\n        <span class=\"hljs-built_in\">Date</span> now = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">Date</span>();\n\n        int dateCompare = now.compareTo(deadTime_Date);\n        <span class=\"hljs-keyword\">if</span> (dateCompare &lt;= <span class=\"hljs-number\">0</span>) {\n            System.out.println(<span class=\"hljs-string\">\"时间剩余\"</span>);\n            long interval = (deadTime_Date.getTime() - now.getTime()) / <span class=\"hljs-number\">60000</span>;\n            result.put(<span class=\"hljs-string\">\"rest_time\"</span>, interval);\n            <span class=\"hljs-keyword\">return</span> ServerResponse.createBySuccess(result);\n        }<span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span>  ServerResponse.createByErrorMessage(<span class=\"hljs-string\">\"当前考试已超时\"</span>);\n        }\n\n    }\n</pre><p><br></p>', '157', '0', '0', '2017-11-24 23:21:23');
INSERT INTO `articles` VALUES ('71', 'test', '本文暂时没有摘要可以显示', 'http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1507616096410temp.png?Expires=1822976087&OSSAccessKeyId=LTAIw9QfPaWovM1p&Signature=mpWM%2F8GSOJ0v%2BDZXMBumt5qdEcE%3D', '3', '2017-10-10 14:14:56', '<p>dfasdf</p>', '53', '0', '0', '2017-11-25 00:14:02');
INSERT INTO `articles` VALUES ('72', 'ces', '本文暂时没有摘要可以显示', 'http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1507616242261temp.jpg?Expires=1822976234&OSSAccessKeyId=LTAIw9QfPaWovM1p&Signature=ShSeqJE6Wq%2FNece56pObcvBh85E%3D', '1', '2017-10-10 14:17:49', '<p><img src=\"http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1507616255172cv.jpg?Expires=1822976247&amp;OSSAccessKeyId=LTAIw9QfPaWovM1p&amp;Signature=i%2FgaUCovxx1y31MeDs09JOAIvQI%3D\"></p>', '91', '0', '0', '2017-11-25 01:47:59');
INSERT INTO `articles` VALUES ('73', '6666', '本文暂时没有摘要可以显示', 'http://oes-bucket.oss-cn-shanghai.aliyuncs.com/OES/images/temp/1511509710999temp.jpg?Expires=1826869708&OSSAccessKeyId=LTAIw9QfPaWovM1p&Signature=eQHm7Zt7lltqbjkh4Sof5TMyGeY%3D', '3', '2017-11-24 15:49:03', '<pre class=\"ql-syntax hljs java\" spellcheck=\"false\">Date now = <span class=\"hljs-keyword\">new</span> Date();\n\n        <span class=\"hljs-keyword\">int</span> dateCompare = now.compareTo(deadTime_Date);\n        <span class=\"hljs-keyword\">if</span> (dateCompare &lt;= <span class=\"hljs-number\">0</span>) {\n            System.out.println(<span class=\"hljs-string\">\"时间剩余\"</span>);\n            <span class=\"hljs-keyword\">long</span> interval = (deadTime_Date.getTime() - now.getTime()) / <span class=\"hljs-number\">60000</span>;\n            result.put(<span class=\"hljs-string\">\"rest_time\"</span>, interval);\n            <span class=\"hljs-keyword\">return</span> ServerResponse.createBySuccess(result);\n        }<span class=\"hljs-keyword\">else</span> {\n            <span class=\"hljs-keyword\">return</span>  ServerResponse.createByErrorMessage(<span class=\"hljs-string\">\"当前考试已超时\"</span>);\n        }\n</pre><p><br></p>', '99', '0', '0', '2017-11-25 01:56:20');
INSERT INTO `articles` VALUES ('74', 'happy up', '本文暂时没有摘要可以显示', 'http://zxx-blog.oss-cn-shanghai.aliyuncs.com/images/1511511061097temp.jpg?Expires=1826871052&OSSAccessKeyId=LTAIw9QfPaWovM1p&Signature=rl4wvAY5smcCeEjmw9yuOCjrRPk%3D', '3', '2017-11-24 16:11:29', '<p>哒哒~~~ 开心点儿 乖乖的~~~ </p>', '105', '0', '0', '2017-11-25 01:47:58');
INSERT INTO `articles` VALUES ('75', '999', '本文暂时没有摘要可以显示', 'http://zxx-blog.oss-cn-shanghai.aliyuncs.com/images/1511514860585temp.jpg?Expires=1826874851&OSSAccessKeyId=LTAIw9QfPaWovM1p&Signature=pLxiu3wsdhqhca69ZdG1JVYSy7s%3D', '2', '2017-11-24 17:18:23', '<p>6666<img src=\"http://zxx-blog.oss-cn-shanghai.aliyuncs.com/images/151151508400629d1a70e47b8017ca6d742c549678abbee80bd80ab85324f1793316aa8056ea9.jpg?Expires=1826875085&amp;OSSAccessKeyId=LTAIw9QfPaWovM1p&amp;Signature=%2Fr8wFNwnKkhfGeTLIrSkeak4oZI%3D\"></p><p><br></p><p><br></p><p>6688</p>', '18', '0', '0', '2017-11-25 00:33:17');
INSERT INTO `articles` VALUES ('76', 'a1', '本文暂时没有摘要可以显示', 'http://zxx-blog.oss-cn-shanghai.aliyuncs.com/images/1511516306284temp.jpg?Expires=1826876302&OSSAccessKeyId=LTAIw9QfPaWovM1p&Signature=tXMS9wjgZKl%2FTb0gNqCjQ9Tohq8%3D', '2', '2017-11-24 17:38:31', '<p>aaaaaaaaaaaa</p>', '9', '0', '0', '2017-11-25 01:47:55');

-- ----------------------------
-- Table structure for articletagrelations
-- ----------------------------
DROP TABLE IF EXISTS `articletagrelations`;
CREATE TABLE `articletagrelations` (
  `articleId` int(8) NOT NULL,
  `tagId` int(4) NOT NULL,
  `remove` int(1) DEFAULT '0',
  PRIMARY KEY (`articleId`,`tagId`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of articletagrelations
-- ----------------------------
INSERT INTO `articletagrelations` VALUES ('1', '1', '0');
INSERT INTO `articletagrelations` VALUES ('1', '2', '0');
INSERT INTO `articletagrelations` VALUES ('30', '2', '0');
INSERT INTO `articletagrelations` VALUES ('30', '22', '0');
INSERT INTO `articletagrelations` VALUES ('31', '2', '0');
INSERT INTO `articletagrelations` VALUES ('31', '22', '0');
INSERT INTO `articletagrelations` VALUES ('31', '24', '0');
INSERT INTO `articletagrelations` VALUES ('32', '2', '0');
INSERT INTO `articletagrelations` VALUES ('32', '22', '0');
INSERT INTO `articletagrelations` VALUES ('33', '2', '0');
INSERT INTO `articletagrelations` VALUES ('33', '22', '0');
INSERT INTO `articletagrelations` VALUES ('34', '2', '0');
INSERT INTO `articletagrelations` VALUES ('34', '22', '0');
INSERT INTO `articletagrelations` VALUES ('35', '2', '0');
INSERT INTO `articletagrelations` VALUES ('35', '22', '0');
INSERT INTO `articletagrelations` VALUES ('36', '2', '0');
INSERT INTO `articletagrelations` VALUES ('36', '22', '0');
INSERT INTO `articletagrelations` VALUES ('36', '23', '0');
INSERT INTO `articletagrelations` VALUES ('37', '25', '0');
INSERT INTO `articletagrelations` VALUES ('38', '25', '0');
INSERT INTO `articletagrelations` VALUES ('38', '27', '0');
INSERT INTO `articletagrelations` VALUES ('39', '2', '0');
INSERT INTO `articletagrelations` VALUES ('39', '22', '0');
INSERT INTO `articletagrelations` VALUES ('40', '2', '0');
INSERT INTO `articletagrelations` VALUES ('40', '22', '0');
INSERT INTO `articletagrelations` VALUES ('41', '2', '0');
INSERT INTO `articletagrelations` VALUES ('41', '22', '0');
INSERT INTO `articletagrelations` VALUES ('42', '2', '0');
INSERT INTO `articletagrelations` VALUES ('42', '22', '0');
INSERT INTO `articletagrelations` VALUES ('43', '25', '0');
INSERT INTO `articletagrelations` VALUES ('43', '26', '0');
INSERT INTO `articletagrelations` VALUES ('44', '25', '0');
INSERT INTO `articletagrelations` VALUES ('44', '26', '0');
INSERT INTO `articletagrelations` VALUES ('45', '25', '0');
INSERT INTO `articletagrelations` VALUES ('45', '26', '0');
INSERT INTO `articletagrelations` VALUES ('46', '25', '0');
INSERT INTO `articletagrelations` VALUES ('46', '26', '0');
INSERT INTO `articletagrelations` VALUES ('47', '2', '0');
INSERT INTO `articletagrelations` VALUES ('47', '22', '0');
INSERT INTO `articletagrelations` VALUES ('48', '2', '0');
INSERT INTO `articletagrelations` VALUES ('48', '22', '0');
INSERT INTO `articletagrelations` VALUES ('49', '2', '0');
INSERT INTO `articletagrelations` VALUES ('49', '22', '0');
INSERT INTO `articletagrelations` VALUES ('50', '2', '0');
INSERT INTO `articletagrelations` VALUES ('50', '22', '0');
INSERT INTO `articletagrelations` VALUES ('51', '2', '0');
INSERT INTO `articletagrelations` VALUES ('52', '2', '0');
INSERT INTO `articletagrelations` VALUES ('53', '2', '0');
INSERT INTO `articletagrelations` VALUES ('55', '23', '0');
INSERT INTO `articletagrelations` VALUES ('56', '29', '0');
INSERT INTO `articletagrelations` VALUES ('56', '30', '0');
INSERT INTO `articletagrelations` VALUES ('57', '25', '0');
INSERT INTO `articletagrelations` VALUES ('58', '1', '0');
INSERT INTO `articletagrelations` VALUES ('60', '8', '0');
INSERT INTO `articletagrelations` VALUES ('61', '8', '0');
INSERT INTO `articletagrelations` VALUES ('62', '25', '0');
INSERT INTO `articletagrelations` VALUES ('63', '1', '0');
INSERT INTO `articletagrelations` VALUES ('64', '31', '0');
INSERT INTO `articletagrelations` VALUES ('64', '32', '0');
INSERT INTO `articletagrelations` VALUES ('64', '33', '0');
INSERT INTO `articletagrelations` VALUES ('65', '1', '0');
INSERT INTO `articletagrelations` VALUES ('65', '2', '0');
INSERT INTO `articletagrelations` VALUES ('65', '8', '0');
INSERT INTO `articletagrelations` VALUES ('65', '23', '0');
INSERT INTO `articletagrelations` VALUES ('66', '2', '0');
INSERT INTO `articletagrelations` VALUES ('67', '1', '0');
INSERT INTO `articletagrelations` VALUES ('68', '1', '0');
INSERT INTO `articletagrelations` VALUES ('71', '2', '0');
INSERT INTO `articletagrelations` VALUES ('72', '1', '0');
INSERT INTO `articletagrelations` VALUES ('73', '1', '0');
INSERT INTO `articletagrelations` VALUES ('73', '22', '0');
INSERT INTO `articletagrelations` VALUES ('73', '23', '0');
INSERT INTO `articletagrelations` VALUES ('74', '112', '0');
INSERT INTO `articletagrelations` VALUES ('75', '1', '0');
INSERT INTO `articletagrelations` VALUES ('75', '23', '0');
INSERT INTO `articletagrelations` VALUES ('76', '2', '0');
INSERT INTO `articletagrelations` VALUES ('76', '36', '0');

-- ----------------------------
-- Table structure for categories
-- ----------------------------
DROP TABLE IF EXISTS `categories`;
CREATE TABLE `categories` (
  `categoryId` int(4) NOT NULL AUTO_INCREMENT,
  `PID` int(4) NOT NULL DEFAULT '0',
  `categoryName` varchar(100) DEFAULT NULL,
  `remove` int(1) DEFAULT '0',
  PRIMARY KEY (`categoryId`,`PID`),
  KEY `categoryId` (`categoryId`)
) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of categories
-- ----------------------------
INSERT INTO `categories` VALUES ('1', '0', 'mybatis', '0');
INSERT INTO `categories` VALUES ('2', '0', 'java', '0');
INSERT INTO `categories` VALUES ('3', '0', '默认分类', '0');

-- ----------------------------
-- Table structure for tags
-- ----------------------------
DROP TABLE IF EXISTS `tags`;
CREATE TABLE `tags` (
  `tagId` int(4) NOT NULL AUTO_INCREMENT,
  `tagName` varchar(20) DEFAULT NULL,
  `remove` int(1) DEFAULT '0',
  PRIMARY KEY (`tagId`)
) ENGINE=InnoDB AUTO_INCREMENT=113 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of tags
-- ----------------------------
INSERT INTO `tags` VALUES ('1', '测试', '0');
INSERT INTO `tags` VALUES ('2', 'test', '0');
INSERT INTO `tags` VALUES ('8', 'test2', '0');
INSERT INTO `tags` VALUES ('11', 'tagName', '0');
INSERT INTO `tags` VALUES ('22', 'linux', '0');
INSERT INTO `tags` VALUES ('23', '上传', '0');
INSERT INTO `tags` VALUES ('25', '算法', '0');
INSERT INTO `tags` VALUES ('26', '图', '0');
INSERT INTO `tags` VALUES ('27', '时间复杂度', '0');
INSERT INTO `tags` VALUES ('28', '关键路径', '0');
INSERT INTO `tags` VALUES ('29', 'java', '0');
INSERT INTO `tags` VALUES ('30', '日期类', '0');
INSERT INTO `tags` VALUES ('34', 'tag', '0');
INSERT INTO `tags` VALUES ('35', 'new Tag', '0');
INSERT INTO `tags` VALUES ('36', 'test', '0');
INSERT INTO `tags` VALUES ('111', 'tagName', '0');
INSERT INTO `tags` VALUES ('112', '开心', '0');

-- ----------------------------
-- Table structure for user
-- ----------------------------
DROP TABLE IF EXISTS `user`;
CREATE TABLE `user` (
  `username` varchar(255) NOT NULL,
  `id` int(8) NOT NULL AUTO_INCREMENT,
  `password` varchar(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=24 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of user
-- ----------------------------
INSERT INTO `user` VALUES ('1', '1', '1');
INSERT INTO `user` VALUES ('12', '12', '2');
INSERT INTO `user` VALUES ('name', '13', '1231');
INSERT INTO `user` VALUES ('admin11', '21', '1111');
INSERT INTO `user` VALUES ('admin11111s', '22', '1111');
INSERT INTO `user` VALUES ('admin11111s', '23', 'aa');
